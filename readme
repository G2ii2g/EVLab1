ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ АВТОНОМНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ
САНКТ-ПЕТЕРБУРГСКИЙ НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ 
ИНФОРМАЦИОННЫХ ТЕХНОЛОГИЙ, МЕХАНИКИ И ОПТИКИ

Отчет
о выполнении лабораторной работы № 1
«СЛОЖНОСТЬ АЛГОРИТМОВ И ИХ ОПТИМИЗАЦИЯ»

Работу выполнил: 
Гордеев И.И. 
Работу принял: 
Муратов С.Ю. 

Санкт-Петербург
2023
 
Цель работы 
Получить навыки вычисления сложности алгоритмов и их оптимизации различными методами. 
Постановка задачи 
1. Реализовать на любом ЯП алгоритм, согласно варианту задания. 
2. Вычислить сложность алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов. 
3. Выполнить оптимизацию как алгоритмическую если возможно, с выносом инварианта, например, так и программными методами выбранного ЯП. 
4. Вычислить сложность оптимизированного алгоритма, привести расчёты, результаты нагрузочных тестов с замером затраченного времени и ресурсов. 
5. Описать различие величин сложности, результатов, привести обоснование. 
6. Сформулировать выводы. 
7. Приложить код в виде ссылки на публичный репозиторий. 
Краткая теоретическая часть 
Вариант 11. Алгоритм Ли.
Алгоритм волновой трассировки (волновой алгоритм, алгоритм Ли) — алгоритм поиска пути, алгоритм поиска кратчайшего пути на планарном графе. Принадлежит к алгоритмам, основанным на методах поиска в ширину.
В основном используется при компьютерной трассировке (разводке) печатных плат, соединительных проводников на поверхности микросхем. Другое применение волнового алгоритма — поиск кратчайшего расстояния на карте в компьютерных стратегических играх.
Волновой алгоритм в контексте поиска пути в лабиринте был предложен Э. Ф. Муром. Ли независимо открыл этот же алгоритм при формализации алгоритмов трассировки печатных плат в 1961 году. 
Результаты 
1. Алгоритм реализован на ЯП Python 3.11, согласно 11 варианту задания.
2. Временная сложность алгоритма составляет O(m*n), где m –количество строк матрицы, n – количество столбцов матрицы. При m=n=500 время выполнения 1,63 с, при m=n=1000 время выполнения 7,04 с, то есть примерно в 4 раза дольше.
3. В первой версии алгоритма, реализованной в функции dictbfsLee, для хранения информации о посещённых ячейках используется словарь, а во второй версии алгоритма, реализованной в функции bfsLee, для хранения информации о посещённых ячейках используется список списков, что позволяет немного ускорить работу.
4. Временная сложность оптимизированного алгоритма составляет O(m*n), где m –количество строк матрицы, n – количество столбцов матрицы, поскольку каждая ячейка по-прежнему обрабатывается один раз. При m=n=500 время выполнения 1,24 с, при m=n=1000 время выполнения 4,59 с, то есть примерно в 4 раза дольше.
5. За счёт использования другой структуры данных немного уменьшается время работы алгоритма.
6. В худшем случае работы алгоритма приходится обрабатывать все ячейки в матрице, поэтому временная сложность обеих версий алгоритма составляет O(m*n), где m –количество строк матрицы. Результаты запусков на разных размерах матриц показывают аналогичную зависимость.
7. Ссылка на репозиторий https://github.com/G2ii2g/EVLab1

